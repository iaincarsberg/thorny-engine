/*global define console*/
define(
	[
		'thorny',
		'thorny!pathfinder>astar/main',
		'thorny!pathfinder>route',
		'thorny!core>math/vector2',
		'thorny!core>math/poly2',
		'thorny!level>level-segment',
		'cjs!underscore'
	], 
	function (
		Thorny,
		AStar,
		route,
		Vector2,
		Poly2,
		LevelSegment,
		underscore
	) {
		var Funnel = {};
		
		Funnel.data = {
			/////////////////////
			// Used in edgeify //
			/////////////////////
			origin: new Vector2(0, 0),
			destination: new Vector2(0, 0),
			
			//////////////////////
			// Used in pointify //
			//////////////////////
			facing: [
				new Vector2(0, 0),
				new Vector2(0, 0),
				new Vector2(0, 0),
				new Vector2(0, 0)
			],
			point: [
				new Vector2(0, 0),
				new Vector2(0, 0),
				new Vector2(0, 0),
				new Vector2(0, 0)
			]
		};
		
		/**
		 * Used to walk around the parimiter of a route generated by the 
		 * AStar impelmentation.
		 * @param object Level level Contains the level we're walking on
		 * @param object Format Contains the format used by the level.
		 * @param array route Contains a list of all shapes the route passes 
		 *        through on its way to its destination.
		 * @param array edges Contains all currently discovered edges within 
		 *        this LevelSegment
		 * @param object lastPushedVector2 Contains the last vector2 added to 
		 *        the edges list
		 * @param object lastShape Contains last shape selected.
		 * @return void
		 */
		Funnel.walkEdge = function (level, Format, route, edges, lastPushedVector2, lastShape) {
			underscore.each(route, function (identifier) {
				var i, ii,
					segment    = level.getSegment(identifier[0]),
					shape      = segment.getShapeById(identifier[1]),
					commonEdge = shape.sharesEdge(lastShape),
					
					shapeLength = Format.getLength(shape),
					from = LevelSegment.edgePicker.apply(null, commonEdge.local),
					id,
					v2s = shape.getVector2s();
				
				// Loop over the shape's vector2s adding the found edges to 
				// the, edges array.
				for (i = 0, ii = shapeLength; i < ii; i += 1) {
					id = [from + i + 1] % shapeLength;
					
					// If the vector2 isn't the same as the previosly added 
					// one, then push it into the edges list.
					if (! v2s[id].sameAs(lastPushedVector2)
					) {	
						lastPushedVector2 = v2s[id];
						edges.push(lastPushedVector2);
					}
					
					// If this is a closed edge, break out of the loop.
					if (segment.isOpenEdge(identifier[1], id)) {
						break;
					}
				}
				
				// Backup the lastShape
				lastShape = shape;
			});
		};
		
		/**
		 * Used to turn the raw a* array into a list of edges.
		 * @param object Level level Contains the level we're walking on
		 * @param object Format Contains the format used by the level.
		 * @param array route Contains a list of all shapes the route passes 
		 *        through on its way to its destination.
		 * @param float fromX Contains the x coordinate of the origin
		 * @param float fromY Contains the y coordinate of the origin
		 * @param float toX Contains the x coordinate of the destination
		 * @param float toY Contains the y coordinate of the destination
		 * @return array Containing a list that makes up the parimiter of the 
		 *         supplied route.
		 */
		Funnel.edgeify = function (level, Format, route, fromX, fromY, toX, toY) {
			/*
			.:NOTE:.
			
			Edgeify works by walking around the parimiter of a complex 
			collection of LevelSegments, and returns an ordered list that 
			details the shape of the collection.
			
			To process this data we take four steps, find the start point
			loop around one side of the shape, then find the end point, then 
			loop back around the other side of the shape.
			*/
			var
				edges = [],
				shape,
				lastShape,
				commonEdge,
				lastVector2,
				lastPushedVector2,
				destinationShape;
			
			
			// If the route is empty return an empty edge list
			if (route.length === 0) {
				return [];
			
			// If the route has one node then return its vectors
			} else if (route.length === 1) {
				shape = level.getSegmentShape.apply(level, route[0]);
				
				return shape.getVector2s();
			}
			
			// Set the origin and destination points.
			this.data.origin
				.setX(fromX)
				.setY(fromY);
				
			this.data.destination
				.setX(toX)
				.setY(toY);
			
			// Shift the first shape out of the route, as its been replaced 
			// with the origin point.
			lastShape = level.getSegmentShape.apply(level, route.shift());
			
			// Pop the last shape out of the route, as its will be replaced 
			// with the destination point.
			destinationShape = level.getSegmentShape.apply(level, route.pop());
			
			
			// Find the common edge with the shift'ed root shape in the route,
			// and current 0th route node.
			commonEdge = lastShape.sharesEdge(
				level.getSegmentShape.apply(level, route[0])
				);
				
			// Using the common edge, we get the first discoverted vector and 
			// store in in the lastPushedVector2 variable, allowing the
			// walkEdge function to operate correctly.
			lastPushedVector2 = lastShape.getVector2s()[
				LevelSegment.edgePicker.apply(null, commonEdge.local)
			];
			
			// Start walking the edges of the route.
			
			// Add the origin, and the first vector2 to be pushed into the 
			// edges list. Then walk one side of the LevelSegment.
			edges.push(this.data.origin);
			edges.push(lastPushedVector2);
			Funnel.walkEdge(
				level, 
				Format, 
				route, 
				edges, 
				lastPushedVector2, 
				lastShape
				);
			
			// Add the destination, then walk the other side of the 
			// LevelSegment, we do this by reversing the route.
			edges.push(this.data.destination);
			Funnel.walkEdge(
				level, 
				Format, 
				route.reverse(), 
				edges, 
				lastPushedVector2, 
				destinationShape
				);
			
			return edges;
		};
		
		/**
		 * Used to project points inward from the edges, allowing entities 
		 * with a radius to move though the network without clipping into
		 * any of the levels edges.
		 * @param array edges Contains the edges of the processed a* path
		 * @param int radius Contains the radius of the entity moving though
		 * the network. 
		 * @return array of vector2s Which mark the safe interal bounderies
		 * based on the parsed radius.
		 */
		Funnel.pointify = function (edges, radius) {
			var route = [],
				edges_length = edges.length;
			
			// Makesure the length is long enough to generate a valid list
			// of projected points.
			if (edges_length < 3) {
				return false;
			}
			
			underscore.each(edges, function (current, id) {
				var previous, next, intersection;
				
				previous = edges[(edges_length + id - 1) % edges_length];
				next     = edges[(id + 1) % edges_length];
				
				intersection = Vector2.lineIntersection(
					Funnel.data.point[0].copy(previous).translate(Funnel.data.facing[0].copy(previous).rotateToFace(current).rotate(90), radius),
					Funnel.data.point[1].copy(current).translate(Funnel.data.facing[1].copy(current).rotateToFace(previous).rotate(-90), radius),

					Funnel.data.point[2].copy(next).translate(Funnel.data.facing[2].copy(next).rotateToFace(current).rotate(-90), radius),
					Funnel.data.point[3].copy(current).translate(Funnel.data.facing[3].copy(current).rotateToFace(next).rotate(90), radius),
					false
					);
				
				route.push(
					intersection
					);
			});
			
			return route;
		};
		
		/**
		 * Used to see if the goal has already been visited.
		 * @param Vector2 goal Contains the current movement goal
		 * @param array route Contains a list of Vector2s that make up the route
		 * @return boolean true if goal is in route
		 */
		Funnel.goalInArray = function (goal, data) {
			var inRoute = false;
			underscore.each(data, function (v2, id) {
				if (inRoute) {
					return;
				}
				
				if (goal.sameAs(v2)) {
					inRoute = {id: id};
				}
			});
			
			return inRoute;
		};
		
		Funnel.hasEdgeIntersection = function (from, to, edges) {
			var hasIntersection = false,
				i,
				ii,
				intersection;

			for (i = 1, ii = edges.length; i < ii; i += 1) {
				if (from.sameAs(edges[i]) ||
					from.sameAs(edges[i - 1]) ||
					to.sameAs(edges[i]) ||
					to.sameAs(edges[i - 1])
				) {
					continue;
				}
				
				// Check for the intersection.
				intersection = Vector2.lineIntersection(
					from,
					to,
					edges[i],
					edges[i - 1]
					);
				
				if (intersection) {
					hasIntersection = true;
				}
			}
			
			return hasIntersection;
		};
		
		/******/
		Funnel.hasRadialIntersection = function (from, to, edges, points) {
			var hasIntersection = false;
			
			// Start
			underscore.each(edges, function (edge, id) {
				var point = points[id],
					intersection;

				if (! point ||
					from.sameAs(edge) ||
					from.sameAs(point) ||
					to.sameAs(edge) ||
					to.sameAs(point)
				) {
					return;
				}

				// Check for the intersection.
				intersection = Vector2.lineIntersection(
					from,
					to,
					edge,
					point
					);
				
				/*
				console.log(
					[
						edge.getIntegerCoords(),
						point.getIntegerCoords()
					]
				);
				*/

				if (intersection) {
					hasIntersection = true;
				}
			});
			
			return hasIntersection;
		};
		
		/**
		 * Used to process a route through the funnel
		 * @param array edges Contains the result of the edgeify function
		 * @param array points Contains the result of the pointify function
		 * @return array Containing a path through the funnel
		 */
		Funnel.process = function (edges, points, toX, toY) {
			Funnel.data.destination
				.setX(toX)
				.setY(toY);
			
			var route = [],
				from = edges[0],
				bestVector2,
				bestDistance;
			
			route.push(from);
			
			points = points.concat(Funnel.data.destination);
			
			while (true) {
				bestVector2 = false;
				bestDistance = false;
				
				console.log('');
				underscore.each(points, function (point, pointId) {
					var eIntersection,
						rIntersection,
						distance;

					if (! point ||
						from.sameAs(point) ||
						Funnel.goalInArray(point, route)
					) {
						return;
					}

					eIntersection = Funnel.hasEdgeIntersection(
						from,
						point,
						edges
						);
					rIntersection = Funnel.hasRadialIntersection(
						from,
						point,
						edges,
						points
						);

					if (eIntersection || rIntersection) {
						return;
					}

					distance = point.distance(Funnel.data.destination) + point.distance(from);
					
					

					// return;
					console.log(
						0, 
						'to', 
						pointId,
						distance,
						point.distance(from)
						);
						
					if (bestDistance === false ||
						distance < bestDistance
					) {
						bestDistance = distance;
						bestVector2 = point;
					}
				});

				if (bestVector2) {
					route.push(bestVector2);
					from = bestVector2;
					
					if (from.sameAs(Funnel.data.destination)) {
						break;
					}
				}
			}
			
			return route;
		};
		
		return Funnel;
	}
);
/*
(function (module, undefined) {
	module.exports = function ($) {
		// Contains a renderer inject function, used for debugging.
		var renderer = false;
		
		return {
			/ **
			 * Used to process an array of nodes into a list of points to travel
			 * though the network.
			 * @param object from Contains the from vector2
			 * @param object to Contains the to vector2
			 * @param array route Contains the result of the a* search though 
			 * the network.
			 * @param int radius Contains the radius of the entity moving though
			 * the network.
			 * @return array Containing the path
			 * /
			process: function (from, to, route, radius) {
				var
					// Contains the edge of the shape
					edges = this.edgeify(route),
					// Will contain the inwardly projected points of the edge
					points;
				
				if (route.length === 0) {
					return [];
				}
				
				// If there is no radius set, then there is no point projecting 
				// the points inwards.
				if (radius === undefined || radius <= 0) {
					return this.funnel(from, to, edges, edges);
					
				// Otherwise we need to project them.
				} else {
					points = this.pointify(route, edges, radius);
					return this.funnel(from, to, edges, points);
				}
			},
			
			
			
			/ **
			 * Used to process the edges and points into a usable path
			 * @param object from Contains the from vector2
			 * @param object to Contains the to vector2
			 * @param array edges Contains the edges of the a* path
			 * @param array points Contains the inward projected points of the 
			 * a* path
			 * @return array Containing the path through the network
			 * /
			funnel: function (from, to, edges, points) {
				var
					size = edges.length,
					nodes = [],
					node = $('thorny level node'),
					v2 = $('thorny math vector2'),
					lineIntersection = $('thorny math vector2')
						.lineIntersection,// Contains the intersection function
					fromV2,
					toV2,
					distance,
					i,	// Used for loop control
					ii,	// Used for loop delimiting
					j,	// Used for loop control
					jj,	// Used for loop delimiting
					
					isValidLink = function (node_from, node_to) {
						var
							intersect,
							rk,
							k,	// Used for loop control
							kk;	// Used for loop delimiting
						
						for (k = 0, kk = size; k < kk; k += 1) {
							rk = (k + 1) % size;
							
							// Check for edge intersections
							if (lineIntersection(node_from, node_to, edges[k], edges[rk]) !== false) {
								return false;
							}
							
							// Check for intersections between the point and the projection
							if (! (i === k  || j === k)) {
								if (lineIntersection(node_from, node_to, points[k], edges[k]) !== false) {
									return false;
								}
							}
						}
						return true;
					};
				
				// Turn the from and to points into a node
				fromV2 = node.factory(from.clone(), 'funnel', 'from');
				toV2 = node.factory(to.clone(), 'funnel', 'to');
				
				// Turn all of the points into a node list
				for (i = 0, ii = size; i < ii; i += 1) {
					nodes.push(
						node.factory(
							points[i].clone(),
							'funnel',
							i
						)
					);
				}
				
				// Create the network links between each of the pointifyed nodes
				for (i = 0, ii = size; i < ii; i += 1) {
					for (j = 0, jj = size; j < jj; j += 1) {
						if (i === j) {
							continue;
						}
						if (isValidLink(nodes[i], nodes[j])) {
							distance = nodes[i].distance(nodes[j]);
							
							nodes[i].addNeighbour(nodes[j], {
								distanceTo: distance
							});
							
							nodes[j].addNeighbour(nodes[i], {
								distanceTo: distance
							});
						}
					}
				}
				
				// Network the from and to points in with the rest of the shape
				j = false;
				if (isValidLink(fromV2, toV2)) {
					distance = fromV2.distance(toV2);
					fromV2.addNeighbour(toV2, {
						distanceTo: distance
					});
					toV2.addNeighbour(fromV2, {
						distanceTo: distance
					});
				}
				for (i = 0, ii = size; i < ii; i += 1) {
					if (isValidLink(fromV2, nodes[i])) {
						distance = fromV2.distance(nodes[i]);
						fromV2.addNeighbour(nodes[i], {
							distanceTo: distance
						});
						nodes[i].addNeighbour(fromV2, {
							distanceTo: distance
						});
					}
				}
				for (i = 0, ii = size; i < ii; i += 1) {
					if (isValidLink(toV2, nodes[i])) {
						distance = toV2.distance(nodes[i]);
						toV2.addNeighbour(nodes[i], {
							distanceTo: distance
						});
						nodes[i].addNeighbour(toV2, {
							distanceTo: distance
						});
					}
				}
//				/ *
//				// Debugging code, to show whats going on inside the funnel
//				// algorithum during the path find process.
//				if (renderer) {
//					(function (renderer, nodes, fromV2, toV2) {
//						var
//							path,
//							node,
//							nes,
//							ne,
//							i,	// Used for loop control
//							ii;	// Used for loop delimiting
//
//						for (i = 0, ii = nodes.length; i < ii; i += 1) {
//							path = [];
//							node = nodes[i];
//							nes = node.getNeightbours();
//							
//							while ((ne = nes.step())) {
//								path.push(node);
//								path.push(ne.node);
//								path.push(node);
//							}
//							
//							renderer.add('path', path);
//						}
//					}(renderer, nodes, fromV2, toV2));
//				}
//				* /
				
				return $('thorny level pathfinder astar').search(
					fromV2,
					toV2,
					undefined,
					function (from, to) {
						return from.distance(to);
					}
				);
			},//funnel
			
			/ **
			 * Used to add debug data to the renderer
			 * @param function injected Contains a renderer inject function
			 * @return void
			 * /
			renderer: function (injected) {
				renderer = injected;
			}
		};
	};
}((typeof window === 'undefined') ? module : window.thorny_path('./thorny/common/level/pathfinder/funnel')));
*/